"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vercel";
exports.ids = ["vendor-chunks/@vercel"];
exports.modules = {

/***/ "(rsc)/../../node_modules/@vercel/blob/dist/chunk-QRRHJ574.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@vercel/blob/dist/chunk-QRRHJ574.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* binding */ BlobAccessError),\n/* harmony export */   BlobError: () => (/* binding */ BlobError),\n/* harmony export */   BlobNotFoundError: () => (/* binding */ BlobNotFoundError),\n/* harmony export */   BlobRequestAbortedError: () => (/* binding */ BlobRequestAbortedError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* binding */ BlobServiceNotAvailable),\n/* harmony export */   BlobServiceRateLimited: () => (/* binding */ BlobServiceRateLimited),\n/* harmony export */   BlobStoreNotFoundError: () => (/* binding */ BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* binding */ BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* binding */ BlobUnknownError),\n/* harmony export */   createCompleteMultipartUploadMethod: () => (/* binding */ createCompleteMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploadMethod: () => (/* binding */ createCreateMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploaderMethod: () => (/* binding */ createCreateMultipartUploaderMethod),\n/* harmony export */   createPutMethod: () => (/* binding */ createPutMethod),\n/* harmony export */   createUploadPartMethod: () => (/* binding */ createUploadPartMethod),\n/* harmony export */   getDownloadUrl: () => (/* binding */ getDownloadUrl),\n/* harmony export */   getTokenFromOptionsOrEnv: () => (/* binding */ getTokenFromOptionsOrEnv),\n/* harmony export */   requestApi: () => (/* binding */ requestApi)\n/* harmony export */ });\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! undici */ \"undici\");\n/* harmony import */ var async_retry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! async-retry */ \"(rsc)/../../node_modules/async-retry/lib/index.js\");\n/* harmony import */ var bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bytes */ \"(rsc)/../../node_modules/bytes/index.js\");\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! is-plain-object */ \"(rsc)/../../node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! is-buffer */ \"(rsc)/../../node_modules/is-buffer/index.js\");\n// src/helpers.ts\nfunction getTokenFromOptionsOrEnv(options) {\n  if (options == null ? void 0 : options.token) {\n    return options.token;\n  }\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n  throw new BlobError(\n    \"No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.\"\n  );\n}\nvar BlobError = class extends Error {\n  constructor(message) {\n    super(`Vercel Blob: ${message}`);\n  }\n};\nfunction getDownloadUrl(blobUrl) {\n  const url = new URL(blobUrl);\n  url.searchParams.set(\"download\", \"1\");\n  return url.toString();\n}\n\n// src/api.ts\n\n\n\n// src/debug.ts\nvar debugIsActive = false;\nvar _a, _b;\ntry {\n  if (((_a = process.env.DEBUG) == null ? void 0 : _a.includes(\"blob\")) || ((_b = process.env.NEXT_PUBLIC_DEBUG) == null ? void 0 : _b.includes(\"blob\"))) {\n    debugIsActive = true;\n  }\n} catch (error) {\n}\nfunction debug(message, ...args) {\n  if (debugIsActive) {\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n\n// src/api.ts\nvar BlobAccessError = class extends BlobError {\n  constructor() {\n    super(\"Access denied, please provide a valid token for this resource.\");\n  }\n};\nvar BlobStoreNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"This store does not exist.\");\n  }\n};\nvar BlobStoreSuspendedError = class extends BlobError {\n  constructor() {\n    super(\"This store has been suspended.\");\n  }\n};\nvar BlobUnknownError = class extends BlobError {\n  constructor() {\n    super(\"Unknown error, please visit https://vercel.com/help.\");\n  }\n};\nvar BlobNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"The requested blob does not exist\");\n  }\n};\nvar BlobServiceNotAvailable = class extends BlobError {\n  constructor() {\n    super(\"The blob service is currently not available. Please try again.\");\n  }\n};\nvar BlobServiceRateLimited = class extends BlobError {\n  constructor(seconds) {\n    super(\n      `Too many requests please lower the number of concurrent requests ${seconds ? ` - try again in ${seconds} seconds` : \"\"}.`\n    );\n    this.retryAfter = seconds != null ? seconds : 0;\n  }\n};\nvar BlobRequestAbortedError = class extends BlobError {\n  constructor() {\n    super(\"The request was aborted.\");\n  }\n};\nvar BLOB_API_VERSION = 7;\nfunction getApiVersion() {\n  let versionOverride = null;\n  try {\n    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n  }\n  return `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`;\n}\nfunction getApiUrl(pathname = \"\") {\n  let baseUrl = null;\n  try {\n    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n  }\n  return `${baseUrl || \"https://blob.vercel-storage.com\"}${pathname}`;\n}\nfunction getRetries() {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || \"10\";\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\nfunction createBlobServiceRateLimited(response) {\n  const retryAfter = response.headers.get(\"retry-after\");\n  return new BlobServiceRateLimited(\n    retryAfter ? parseInt(retryAfter, 10) : void 0\n  );\n}\nasync function getBlobError(response) {\n  var _a2, _b2, _c;\n  let code;\n  let message;\n  try {\n    const data = await response.json();\n    code = (_b2 = (_a2 = data.error) == null ? void 0 : _a2.code) != null ? _b2 : \"unknown_error\";\n    message = (_c = data.error) == null ? void 0 : _c.message;\n  } catch {\n    code = \"unknown_error\";\n  }\n  let error;\n  switch (code) {\n    case \"store_suspended\":\n      error = new BlobStoreSuspendedError();\n      break;\n    case \"forbidden\":\n      error = new BlobAccessError();\n      break;\n    case \"not_found\":\n      error = new BlobNotFoundError();\n      break;\n    case \"store_not_found\":\n      error = new BlobStoreNotFoundError();\n      break;\n    case \"bad_request\":\n      error = new BlobError(message != null ? message : \"Bad request\");\n      break;\n    case \"service_unavailable\":\n      error = new BlobServiceNotAvailable();\n      break;\n    case \"rate_limited\":\n      error = createBlobServiceRateLimited(response);\n      break;\n    case \"unknown_error\":\n    case \"not_allowed\":\n    default:\n      error = new BlobUnknownError();\n      break;\n  }\n  return { code, error };\n}\nasync function requestApi(pathname, init, commandOptions) {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n  const extraHeaders = getProxyThroughAlternativeApiHeaderFromEnv();\n  const [, , , storeId = \"\"] = token.split(\"_\");\n  const requestId = `${storeId}:${Date.now()}:${Math.random().toString(16).slice(2)}`;\n  let retryCount = 0;\n  const apiResponse = await async_retry__WEBPACK_IMPORTED_MODULE_1__(\n    async (bail) => {\n      let res;\n      try {\n        res = await (0,undici__WEBPACK_IMPORTED_MODULE_0__.fetch)(getApiUrl(pathname), {\n          ...init,\n          headers: {\n            \"x-api-blob-request-id\": requestId,\n            \"x-api-blob-request-attempt\": String(retryCount),\n            \"x-api-version\": apiVersion,\n            authorization: `Bearer ${token}`,\n            ...extraHeaders,\n            ...init.headers\n          }\n        });\n      } catch (error2) {\n        if (error2 instanceof DOMException && error2.name === \"AbortError\") {\n          bail(new BlobRequestAbortedError());\n          return;\n        }\n        throw error2;\n      }\n      if (res.ok) {\n        return res;\n      }\n      const { code, error } = await getBlobError(res);\n      if (code === \"unknown_error\" || code === \"service_unavailable\" || code === \"internal_server_error\") {\n        throw error;\n      }\n      bail(error);\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        debug(`retrying API request to ${pathname}`, error.message);\n        retryCount = retryCount + 1;\n      }\n    }\n  );\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n  return await apiResponse.json();\n}\nfunction getProxyThroughAlternativeApiHeaderFromEnv() {\n  const extraHeaders = {};\n  try {\n    if (\"VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- we know it's here from the if\n      process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    } else if (\"NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- we know it's here from the if\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    }\n  } catch {\n  }\n  return extraHeaders;\n}\n\n// src/put-helpers.ts\nvar putOptionHeaderMap = {\n  cacheControlMaxAge: \"x-cache-control-max-age\",\n  addRandomSuffix: \"x-add-random-suffix\",\n  contentType: \"x-content-type\"\n};\nfunction createPutHeaders(allowedOptions, options) {\n  const headers = {};\n  if (allowedOptions.includes(\"contentType\") && options.contentType) {\n    headers[putOptionHeaderMap.contentType] = options.contentType;\n  }\n  if (allowedOptions.includes(\"addRandomSuffix\") && options.addRandomSuffix !== void 0) {\n    headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (allowedOptions.includes(\"cacheControlMaxAge\") && options.cacheControlMaxAge !== void 0) {\n    headers[putOptionHeaderMap.cacheControlMaxAge] = options.cacheControlMaxAge.toString();\n  }\n  return headers;\n}\nasync function createPutOptions({\n  pathname,\n  options,\n  extraChecks,\n  getToken\n}) {\n  if (!pathname) {\n    throw new BlobError(\"pathname is required\");\n  }\n  if (!options) {\n    throw new BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new BlobError('access must be \"public\"');\n  }\n  if (extraChecks) {\n    extraChecks(options);\n  }\n  if (getToken) {\n    options.token = await getToken(pathname, options);\n  }\n  return options;\n}\n\n// src/multipart/complete.ts\nfunction createCompleteMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, parts, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    return completeMultipartUpload({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      headers,\n      options,\n      parts\n    });\n  };\n}\nasync function completeMultipartUpload({\n  uploadId,\n  key,\n  pathname,\n  parts,\n  headers,\n  options\n}) {\n  try {\n    const response = await requestApi(\n      `/mpu/${pathname}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"content-type\": \"application/json\",\n          \"x-mpu-action\": \"complete\",\n          \"x-mpu-upload-id\": uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n          \"x-mpu-key\": encodeURI(key)\n        },\n        body: JSON.stringify(parts),\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: complete\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\n// src/multipart/create.ts\nfunction createCreateMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId\n    };\n  };\n}\nasync function createMultipartUpload(pathname, headers, options) {\n  debug(\"mpu: create\", \"pathname:\", pathname);\n  try {\n    const response = await requestApi(\n      `/mpu/${pathname}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"x-mpu-action\": \"create\"\n        },\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: create\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\n// src/multipart/upload.ts\n\n\nfunction createUploadPartMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, body, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const result = await uploadPart({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      part: { blob: body, partNumber: options.partNumber },\n      headers,\n      options\n    });\n    return {\n      etag: result.etag,\n      partNumber: options.partNumber\n    };\n  };\n}\nasync function uploadPart({\n  uploadId,\n  key,\n  pathname,\n  headers,\n  options,\n  internalAbortController = new AbortController(),\n  part\n}) {\n  var _a2, _b2, _c;\n  const responsePromise = requestApi(\n    `/mpu/${pathname}`,\n    {\n      signal: internalAbortController.signal,\n      method: \"POST\",\n      headers: {\n        ...headers,\n        \"x-mpu-action\": \"upload\",\n        \"x-mpu-key\": encodeURI(key),\n        \"x-mpu-upload-id\": uploadId,\n        \"x-mpu-part-number\": part.partNumber.toString()\n      },\n      // weird things between undici types and native fetch types\n      body: part.blob,\n      // required in order to stream some body types to Cloudflare\n      // currently only supported in Node.js, we may have to feature detect this\n      // note: this doesn't send a content-length to the server\n      duplex: \"half\"\n    },\n    options\n  );\n  function handleAbort() {\n    internalAbortController.abort();\n  }\n  if ((_a2 = options.abortSignal) == null ? void 0 : _a2.aborted) {\n    handleAbort();\n  } else {\n    (_b2 = options.abortSignal) == null ? void 0 : _b2.addEventListener(\"abort\", handleAbort);\n  }\n  const response = await responsePromise;\n  (_c = options.abortSignal) == null ? void 0 : _c.removeEventListener(\"abort\", handleAbort);\n  return response;\n}\nvar maxConcurrentUploads = typeof window !== \"undefined\" ? 6 : 8;\nvar partSizeInBytes = 8 * 1024 * 1024;\nvar maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\nfunction uploadAllParts({\n  uploadId,\n  key,\n  pathname,\n  stream,\n  headers,\n  options\n}) {\n  debug(\"mpu: upload init\", \"key:\", key);\n  const internalAbortController = new AbortController();\n  return new Promise((resolve, reject) => {\n    const partsToUpload = [];\n    const completedParts = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n    let arrayBuffers = [];\n    let currentPartBytesRead = 0;\n    read().catch(cancel);\n    async function read() {\n      debug(\n        \"mpu: upload read start\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n      );\n      reading = true;\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          const { value, done } = await reader.read();\n          if (done) {\n            doneReading = true;\n            debug(\"mpu: upload read consumed the whole stream\");\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n          currentBytesInMemory += value.byteLength;\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength\n            );\n            const chunk = value.slice(valueOffset, endOffset);\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n      debug(\n        \"mpu: upload read end\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n      );\n      reading = false;\n    }\n    async function sendPart(part) {\n      activeUploads++;\n      debug(\n        \"mpu: upload send part start\",\n        \"partNumber:\",\n        part.partNumber,\n        \"size:\",\n        part.blob.size,\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n      );\n      try {\n        const completedPart = await uploadPart({\n          uploadId,\n          key,\n          pathname,\n          headers,\n          options,\n          internalAbortController,\n          part\n        });\n        debug(\n          \"mpu: upload send part end\",\n          \"partNumber:\",\n          part.partNumber,\n          \"activeUploads\",\n          activeUploads,\n          \"currentBytesInMemory:\",\n          `${bytes__WEBPACK_IMPORTED_MODULE_2__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_2__(maxBytesInMemory)}`,\n          \"bytesSent:\",\n          bytes__WEBPACK_IMPORTED_MODULE_2__(bytesSent)\n        );\n        if (rejected) {\n          return;\n        }\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag\n        });\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        cancel(error);\n      }\n    }\n    function sendParts() {\n      if (rejected) {\n        return;\n      }\n      debug(\n        \"send parts\",\n        \"activeUploads\",\n        activeUploads,\n        \"partsToUpload\",\n        partsToUpload.length\n      );\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n    function cancel(error) {\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error);\n      }\n    }\n  });\n}\n\n// src/put.ts\n\n\n// src/multipart/helpers.ts\n\n\nfunction toReadableStream(value) {\n  if (value instanceof ReadableStream) {\n    return value;\n  }\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n  if (isNodeJsReadableStream(value)) {\n    return stream__WEBPACK_IMPORTED_MODULE_4__.Readable.toWeb(value);\n  }\n  let streamValue;\n  if (value instanceof ArrayBuffer) {\n    streamValue = value;\n  } else if (isNodeJsBufferOrString(value)) {\n    streamValue = value.buffer;\n  } else {\n    streamValue = stringToUint8Array(value);\n  }\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    }\n  });\n}\nfunction isNodeJsReadableStream(value) {\n  return typeof value === \"object\" && typeof value.pipe === \"function\" && value.readable && typeof value._read === \"function\" && // @ts-expect-error _readableState does exists on Readable\n  typeof value._readableState === \"object\";\n}\nfunction stringToUint8Array(s) {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\nfunction isNodeJsBufferOrString(input) {\n  return is_buffer__WEBPACK_IMPORTED_MODULE_5__(input);\n}\n\n// src/multipart/uncontrolled.ts\nasync function uncontrolledMultipartUpload(pathname, body, headers, options) {\n  debug(\"mpu: init\", \"pathname:\", pathname, \"headers:\", headers);\n  const stream = toReadableStream(body);\n  const createMultipartUploadResponse = await createMultipartUpload(\n    pathname,\n    headers,\n    options\n  );\n  const parts = await uploadAllParts({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options\n  });\n  const blob = await completeMultipartUpload({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options\n  });\n  return blob;\n}\n\n// src/put.ts\nfunction createPutMethod({\n  allowedOptions,\n  getToken,\n  extraChecks\n}) {\n  return async function put(pathname, bodyOrOptions, optionsInput) {\n    const isFolderCreation = pathname.endsWith(\"/\");\n    if (!bodyOrOptions && !isFolderCreation) {\n      throw new BlobError(\"body is required\");\n    }\n    if (bodyOrOptions && optionsInput && isFolderCreation) {\n      throw new BlobError(\"body is not allowed for creating empty folders\");\n    }\n    const body = isFolderCreation ? void 0 : bodyOrOptions;\n    if (body !== void 0 && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const options = await createPutOptions({\n      pathname,\n      // when no body is required (for folder creations) options are the second argument\n      options: isFolderCreation ? bodyOrOptions : optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (options.multipart === true && body) {\n      return uncontrolledMultipartUpload(pathname, body, headers, options);\n    }\n    const response = await requestApi(\n      `/${pathname}`,\n      {\n        method: \"PUT\",\n        body,\n        headers,\n        // required in order to stream some body types to Cloudflare\n        // currently only supported in Node.js, we may have to feature detect this\n        // note: this doesn't send a content-length to the server\n        duplex: \"half\",\n        signal: options.abortSignal\n      },\n      options\n    );\n    return {\n      url: response.url,\n      downloadUrl: response.downloadUrl,\n      pathname: response.pathname,\n      contentType: response.contentType,\n      contentDisposition: response.contentDisposition\n    };\n  };\n}\n\n// src/multipart/create-uploader.ts\n\nfunction createCreateMultipartUploaderMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n      async uploadPart(partNumber, body) {\n        if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(body)) {\n          throw new BlobError(\n            \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n          );\n        }\n        const result = await uploadPart({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          part: { partNumber, blob: body },\n          headers,\n          options\n        });\n        return {\n          etag: result.etag,\n          partNumber\n        };\n      },\n      async complete(parts) {\n        return completeMultipartUpload({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          parts,\n          headers,\n          options\n        });\n      }\n    };\n  };\n}\n\n\n//# sourceMappingURL=chunk-QRRHJ574.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvYmxvYi9kaXN0L2NodW5rLVFSUkhKNTc0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQytCO0FBQ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsNkJBQTZCLFNBQVMsY0FBYztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWSw2REFBNkQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFlBQVksNkNBQTZDLEVBQUUsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDa0U7QUFDbEUsK0NBQStDLHVDQUF1QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFvQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2h1bmstUVJSSEo1NzQuanM/YzcxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaGVscGVycy50c1xuZnVuY3Rpb24gZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9rZW4pIHtcbiAgICByZXR1cm4gb3B0aW9ucy50b2tlbjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuQkxPQl9SRUFEX1dSSVRFX1RPS0VOKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkJMT0JfUkVBRF9XUklURV9UT0tFTjtcbiAgfVxuICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgIFwiTm8gdG9rZW4gZm91bmQuIEVpdGhlciBjb25maWd1cmUgdGhlIGBCTE9CX1JFQURfV1JJVEVfVE9LRU5gIGVudmlyb25tZW50IHZhcmlhYmxlLCBvciBwYXNzIGEgYHRva2VuYCBvcHRpb24gdG8geW91ciBjYWxscy5cIlxuICApO1xufVxudmFyIEJsb2JFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoYFZlcmNlbCBCbG9iOiAke21lc3NhZ2V9YCk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXREb3dubG9hZFVybChibG9iVXJsKSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoYmxvYlVybCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiZG93bmxvYWRcIiwgXCIxXCIpO1xuICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8vIHNyYy9hcGkudHNcbmltcG9ydCB7IGZldGNoIH0gZnJvbSBcInVuZGljaVwiO1xuaW1wb3J0IHJldHJ5IGZyb20gXCJhc3luYy1yZXRyeVwiO1xuXG4vLyBzcmMvZGVidWcudHNcbnZhciBkZWJ1Z0lzQWN0aXZlID0gZmFsc2U7XG52YXIgX2EsIF9iO1xudHJ5IHtcbiAgaWYgKCgoX2EgPSBwcm9jZXNzLmVudi5ERUJVRykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwiYmxvYlwiKSkgfHwgKChfYiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0RFQlVHKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJibG9iXCIpKSkge1xuICAgIGRlYnVnSXNBY3RpdmUgPSB0cnVlO1xuICB9XG59IGNhdGNoIChlcnJvcikge1xufVxuZnVuY3Rpb24gZGVidWcobWVzc2FnZSwgLi4uYXJncykge1xuICBpZiAoZGVidWdJc0FjdGl2ZSkge1xuICAgIGNvbnNvbGUuZGVidWcoYHZlcmNlbC1ibG9iOiAke21lc3NhZ2V9YCwgLi4uYXJncyk7XG4gIH1cbn1cblxuLy8gc3JjL2FwaS50c1xudmFyIEJsb2JBY2Nlc3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJBY2Nlc3MgZGVuaWVkLCBwbGVhc2UgcHJvdmlkZSBhIHZhbGlkIHRva2VuIGZvciB0aGlzIHJlc291cmNlLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iU3RvcmVOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoaXMgc3RvcmUgZG9lcyBub3QgZXhpc3QuXCIpO1xuICB9XG59O1xudmFyIEJsb2JTdG9yZVN1c3BlbmRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoaXMgc3RvcmUgaGFzIGJlZW4gc3VzcGVuZGVkLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iVW5rbm93bkVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlVua25vd24gZXJyb3IsIHBsZWFzZSB2aXNpdCBodHRwczovL3ZlcmNlbC5jb20vaGVscC5cIik7XG4gIH1cbn07XG52YXIgQmxvYk5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhlIHJlcXVlc3RlZCBibG9iIGRvZXMgbm90IGV4aXN0XCIpO1xuICB9XG59O1xudmFyIEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoZSBibG9iIHNlcnZpY2UgaXMgY3VycmVudGx5IG5vdCBhdmFpbGFibGUuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICB9XG59O1xudmFyIEJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNlY29uZHMpIHtcbiAgICBzdXBlcihcbiAgICAgIGBUb28gbWFueSByZXF1ZXN0cyBwbGVhc2UgbG93ZXIgdGhlIG51bWJlciBvZiBjb25jdXJyZW50IHJlcXVlc3RzICR7c2Vjb25kcyA/IGAgLSB0cnkgYWdhaW4gaW4gJHtzZWNvbmRzfSBzZWNvbmRzYCA6IFwiXCJ9LmBcbiAgICApO1xuICAgIHRoaXMucmV0cnlBZnRlciA9IHNlY29uZHMgIT0gbnVsbCA/IHNlY29uZHMgOiAwO1xuICB9XG59O1xudmFyIEJsb2JSZXF1ZXN0QWJvcnRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkLlwiKTtcbiAgfVxufTtcbnZhciBCTE9CX0FQSV9WRVJTSU9OID0gNztcbmZ1bmN0aW9uIGdldEFwaVZlcnNpb24oKSB7XG4gIGxldCB2ZXJzaW9uT3ZlcnJpZGUgPSBudWxsO1xuICB0cnkge1xuICAgIHZlcnNpb25PdmVycmlkZSA9IHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX0FQSV9WRVJTSU9OX09WRVJSSURFIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX0FQSV9WRVJTSU9OX09WRVJSSURFO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gYCR7dmVyc2lvbk92ZXJyaWRlICE9IG51bGwgPyB2ZXJzaW9uT3ZlcnJpZGUgOiBCTE9CX0FQSV9WRVJTSU9OfWA7XG59XG5mdW5jdGlvbiBnZXRBcGlVcmwocGF0aG5hbWUgPSBcIlwiKSB7XG4gIGxldCBiYXNlVXJsID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBiYXNlVXJsID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfQVBJX1VSTCB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVVJMO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gYCR7YmFzZVVybCB8fCBcImh0dHBzOi8vYmxvYi52ZXJjZWwtc3RvcmFnZS5jb21cIn0ke3BhdGhuYW1lfWA7XG59XG5mdW5jdGlvbiBnZXRSZXRyaWVzKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJldHJpZXMgPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9SRVRSSUVTIHx8IFwiMTBcIjtcbiAgICByZXR1cm4gcGFyc2VJbnQocmV0cmllcywgMTApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gMTA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQocmVzcG9uc2UpIHtcbiAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwicmV0cnktYWZ0ZXJcIik7XG4gIHJldHVybiBuZXcgQmxvYlNlcnZpY2VSYXRlTGltaXRlZChcbiAgICByZXRyeUFmdGVyID8gcGFyc2VJbnQocmV0cnlBZnRlciwgMTApIDogdm9pZCAwXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCbG9iRXJyb3IocmVzcG9uc2UpIHtcbiAgdmFyIF9hMiwgX2IyLCBfYztcbiAgbGV0IGNvZGU7XG4gIGxldCBtZXNzYWdlO1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29kZSA9IChfYjIgPSAoX2EyID0gZGF0YS5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb2RlKSAhPSBudWxsID8gX2IyIDogXCJ1bmtub3duX2Vycm9yXCI7XG4gICAgbWVzc2FnZSA9IChfYyA9IGRhdGEuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYy5tZXNzYWdlO1xuICB9IGNhdGNoIHtcbiAgICBjb2RlID0gXCJ1bmtub3duX2Vycm9yXCI7XG4gIH1cbiAgbGV0IGVycm9yO1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIFwic3RvcmVfc3VzcGVuZGVkXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iU3RvcmVTdXNwZW5kZWRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZvcmJpZGRlblwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkFjY2Vzc0Vycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibm90X2ZvdW5kXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iTm90Rm91bmRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0b3JlX25vdF9mb3VuZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlN0b3JlTm90Rm91bmRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJhZF9yZXF1ZXN0XCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iRXJyb3IobWVzc2FnZSAhPSBudWxsID8gbWVzc2FnZSA6IFwiQmFkIHJlcXVlc3RcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic2VydmljZV91bmF2YWlsYWJsZVwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyYXRlX2xpbWl0ZWRcIjpcbiAgICAgIGVycm9yID0gY3JlYXRlQmxvYlNlcnZpY2VSYXRlTGltaXRlZChyZXNwb25zZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidW5rbm93bl9lcnJvclwiOlxuICAgIGNhc2UgXCJub3RfYWxsb3dlZFwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iVW5rbm93bkVycm9yKCk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4geyBjb2RlLCBlcnJvciB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEFwaShwYXRobmFtZSwgaW5pdCwgY29tbWFuZE9wdGlvbnMpIHtcbiAgY29uc3QgYXBpVmVyc2lvbiA9IGdldEFwaVZlcnNpb24oKTtcbiAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYoY29tbWFuZE9wdGlvbnMpO1xuICBjb25zdCBleHRyYUhlYWRlcnMgPSBnZXRQcm94eVRocm91Z2hBbHRlcm5hdGl2ZUFwaUhlYWRlckZyb21FbnYoKTtcbiAgY29uc3QgWywgLCAsIHN0b3JlSWQgPSBcIlwiXSA9IHRva2VuLnNwbGl0KFwiX1wiKTtcbiAgY29uc3QgcmVxdWVzdElkID0gYCR7c3RvcmVJZH06JHtEYXRlLm5vdygpfToke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnNsaWNlKDIpfWA7XG4gIGxldCByZXRyeUNvdW50ID0gMDtcbiAgY29uc3QgYXBpUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICBhc3luYyAoYmFpbCkgPT4ge1xuICAgICAgbGV0IHJlcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IGZldGNoKGdldEFwaVVybChwYXRobmFtZSksIHtcbiAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwieC1hcGktYmxvYi1yZXF1ZXN0LWlkXCI6IHJlcXVlc3RJZCxcbiAgICAgICAgICAgIFwieC1hcGktYmxvYi1yZXF1ZXN0LWF0dGVtcHRcIjogU3RyaW5nKHJldHJ5Q291bnQpLFxuICAgICAgICAgICAgXCJ4LWFwaS12ZXJzaW9uXCI6IGFwaVZlcnNpb24sXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgIC4uLmV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgIC4uLmluaXQuaGVhZGVyc1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvcjIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICBiYWlsKG5ldyBCbG9iUmVxdWVzdEFib3J0ZWRFcnJvcigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgfVxuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjb2RlLCBlcnJvciB9ID0gYXdhaXQgZ2V0QmxvYkVycm9yKHJlcyk7XG4gICAgICBpZiAoY29kZSA9PT0gXCJ1bmtub3duX2Vycm9yXCIgfHwgY29kZSA9PT0gXCJzZXJ2aWNlX3VuYXZhaWxhYmxlXCIgfHwgY29kZSA9PT0gXCJpbnRlcm5hbF9zZXJ2ZXJfZXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGJhaWwoZXJyb3IpO1xuICAgIH0sXG4gICAge1xuICAgICAgcmV0cmllczogZ2V0UmV0cmllcygpLFxuICAgICAgb25SZXRyeTogKGVycm9yKSA9PiB7XG4gICAgICAgIGRlYnVnKGByZXRyeWluZyBBUEkgcmVxdWVzdCB0byAke3BhdGhuYW1lfWAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICByZXRyeUNvdW50ID0gcmV0cnlDb3VudCArIDE7XG4gICAgICB9XG4gICAgfVxuICApO1xuICBpZiAoIWFwaVJlc3BvbnNlKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JVbmtub3duRXJyb3IoKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgYXBpUmVzcG9uc2UuanNvbigpO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlUaHJvdWdoQWx0ZXJuYXRpdmVBcGlIZWFkZXJGcm9tRW52KCkge1xuICBjb25zdCBleHRyYUhlYWRlcnMgPSB7fTtcbiAgdHJ5IHtcbiAgICBpZiAoXCJWRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSVwiIGluIHByb2Nlc3MuZW52KSB7XG4gICAgICBleHRyYUhlYWRlcnNbXCJ4LXByb3h5LXRocm91Z2gtYWx0ZXJuYXRpdmUtYXBpXCJdID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gLS0gd2Uga25vdyBpdCdzIGhlcmUgZnJvbSB0aGUgaWZcbiAgICAgIHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJO1xuICAgIH0gZWxzZSBpZiAoXCJORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSVwiIGluIHByb2Nlc3MuZW52KSB7XG4gICAgICBleHRyYUhlYWRlcnNbXCJ4LXByb3h5LXRocm91Z2gtYWx0ZXJuYXRpdmUtYXBpXCJdID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gLS0gd2Uga25vdyBpdCdzIGhlcmUgZnJvbSB0aGUgaWZcbiAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGV4dHJhSGVhZGVycztcbn1cblxuLy8gc3JjL3B1dC1oZWxwZXJzLnRzXG52YXIgcHV0T3B0aW9uSGVhZGVyTWFwID0ge1xuICBjYWNoZUNvbnRyb2xNYXhBZ2U6IFwieC1jYWNoZS1jb250cm9sLW1heC1hZ2VcIixcbiAgYWRkUmFuZG9tU3VmZml4OiBcIngtYWRkLXJhbmRvbS1zdWZmaXhcIixcbiAgY29udGVudFR5cGU6IFwieC1jb250ZW50LXR5cGVcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJjb250ZW50VHlwZVwiKSAmJiBvcHRpb25zLmNvbnRlbnRUeXBlKSB7XG4gICAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuY29udGVudFR5cGVdID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgfVxuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJhZGRSYW5kb21TdWZmaXhcIikgJiYgb3B0aW9ucy5hZGRSYW5kb21TdWZmaXggIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmFkZFJhbmRvbVN1ZmZpeF0gPSBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCA/IFwiMVwiIDogXCIwXCI7XG4gIH1cbiAgaWYgKGFsbG93ZWRPcHRpb25zLmluY2x1ZGVzKFwiY2FjaGVDb250cm9sTWF4QWdlXCIpICYmIG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5jYWNoZUNvbnRyb2xNYXhBZ2VdID0gb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVB1dE9wdGlvbnMoe1xuICBwYXRobmFtZSxcbiAgb3B0aW9ucyxcbiAgZXh0cmFDaGVja3MsXG4gIGdldFRva2VuXG59KSB7XG4gIGlmICghcGF0aG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwicGF0aG5hbWUgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIm1pc3Npbmcgb3B0aW9ucywgc2VlIHVzYWdlXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLmFjY2VzcyAhPT0gXCJwdWJsaWNcIikge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoJ2FjY2VzcyBtdXN0IGJlIFwicHVibGljXCInKTtcbiAgfVxuICBpZiAoZXh0cmFDaGVja3MpIHtcbiAgICBleHRyYUNoZWNrcyhvcHRpb25zKTtcbiAgfVxuICBpZiAoZ2V0VG9rZW4pIHtcbiAgICBvcHRpb25zLnRva2VuID0gYXdhaXQgZ2V0VG9rZW4ocGF0aG5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L2NvbXBsZXRlLnRzXG5mdW5jdGlvbiBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBwYXJ0cywgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gICAgICB1cGxvYWRJZDogb3B0aW9ucy51cGxvYWRJZCxcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBvcHRpb25zLFxuICAgICAgcGFydHNcbiAgICB9KTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKHtcbiAgdXBsb2FkSWQsXG4gIGtleSxcbiAgcGF0aG5hbWUsXG4gIHBhcnRzLFxuICBoZWFkZXJzLFxuICBvcHRpb25zXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgICAgYC9tcHUvJHtwYXRobmFtZX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICBcIngtbXB1LWFjdGlvblwiOiBcImNvbXBsZXRlXCIsXG4gICAgICAgICAgXCJ4LW1wdS11cGxvYWQtaWRcIjogdXBsb2FkSWQsXG4gICAgICAgICAgLy8ga2V5IGNhbiBiZSBhbnkgdXRmOCBjaGFyYWN0ZXIgc28gd2UgbmVlZCB0byBlbmNvZGUgaXQgYXMgSFRUUCBoZWFkZXJzIGNhbiBvbmx5IGJlIHVzLWFzY2lpXG4gICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzAjc3dlY3Rpb24tMy4yLjRcbiAgICAgICAgICBcIngtbXB1LWtleVwiOiBlbmNvZGVVUkkoa2V5KVxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXJ0cyksXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGRlYnVnKFwibXB1OiBjb21wbGV0ZVwiLCByZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyb3IubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L2NyZWF0ZS50c1xuZnVuY3Rpb24gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kKHsgYWxsb3dlZE9wdGlvbnMsIGdldFRva2VuLCBleHRyYUNoZWNrcyB9KSB7XG4gIHJldHVybiBhc3luYyAocGF0aG5hbWUsIG9wdGlvbnNJbnB1dCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZU11bHRpcGFydFVwbG9hZChcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgaGVhZGVycyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZFxuICAgIH07XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVNdWx0aXBhcnRVcGxvYWQocGF0aG5hbWUsIGhlYWRlcnMsIG9wdGlvbnMpIHtcbiAgZGVidWcoXCJtcHU6IGNyZWF0ZVwiLCBcInBhdGhuYW1lOlwiLCBwYXRobmFtZSk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgICAgYC9tcHUvJHtwYXRobmFtZX1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICBcIngtbXB1LWFjdGlvblwiOiBcImNyZWF0ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGRlYnVnKFwibXB1OiBjcmVhdGVcIiwgcmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgKGVycm9yLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL211bHRpcGFydC91cGxvYWQudHNcbmltcG9ydCBieXRlcyBmcm9tIFwiYnl0ZXNcIjtcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tIFwiaXMtcGxhaW4tb2JqZWN0XCI7XG5mdW5jdGlvbiBjcmVhdGVVcGxvYWRQYXJ0TWV0aG9kKHsgYWxsb3dlZE9wdGlvbnMsIGdldFRva2VuLCBleHRyYUNoZWNrcyB9KSB7XG4gIHJldHVybiBhc3luYyAocGF0aG5hbWUsIGJvZHksIG9wdGlvbnNJbnB1dCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChib2R5KSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgXCJCb2R5IG11c3QgYmUgYSBzdHJpbmcsIGJ1ZmZlciBvciBzdHJlYW0uIFlvdSBzZW50IGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QsIGRvdWJsZSBjaGVjayB3aGF0IHlvdSdyZSB0cnlpbmcgdG8gdXBsb2FkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGxvYWRQYXJ0KHtcbiAgICAgIHVwbG9hZElkOiBvcHRpb25zLnVwbG9hZElkLFxuICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgcGFydDogeyBibG9iOiBib2R5LCBwYXJ0TnVtYmVyOiBvcHRpb25zLnBhcnROdW1iZXIgfSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV0YWc6IHJlc3VsdC5ldGFnLFxuICAgICAgcGFydE51bWJlcjogb3B0aW9ucy5wYXJ0TnVtYmVyXG4gICAgfTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZFBhcnQoe1xuICB1cGxvYWRJZCxcbiAga2V5LFxuICBwYXRobmFtZSxcbiAgaGVhZGVycyxcbiAgb3B0aW9ucyxcbiAgaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCksXG4gIHBhcnRcbn0pIHtcbiAgdmFyIF9hMiwgX2IyLCBfYztcbiAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gcmVxdWVzdEFwaShcbiAgICBgL21wdS8ke3BhdGhuYW1lfWAsXG4gICAge1xuICAgICAgc2lnbmFsOiBpbnRlcm5hbEFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICBcIngtbXB1LWFjdGlvblwiOiBcInVwbG9hZFwiLFxuICAgICAgICBcIngtbXB1LWtleVwiOiBlbmNvZGVVUkkoa2V5KSxcbiAgICAgICAgXCJ4LW1wdS11cGxvYWQtaWRcIjogdXBsb2FkSWQsXG4gICAgICAgIFwieC1tcHUtcGFydC1udW1iZXJcIjogcGFydC5wYXJ0TnVtYmVyLnRvU3RyaW5nKClcbiAgICAgIH0sXG4gICAgICAvLyB3ZWlyZCB0aGluZ3MgYmV0d2VlbiB1bmRpY2kgdHlwZXMgYW5kIG5hdGl2ZSBmZXRjaCB0eXBlc1xuICAgICAgYm9keTogcGFydC5ibG9iLFxuICAgICAgLy8gcmVxdWlyZWQgaW4gb3JkZXIgdG8gc3RyZWFtIHNvbWUgYm9keSB0eXBlcyB0byBDbG91ZGZsYXJlXG4gICAgICAvLyBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gTm9kZS5qcywgd2UgbWF5IGhhdmUgdG8gZmVhdHVyZSBkZXRlY3QgdGhpc1xuICAgICAgLy8gbm90ZTogdGhpcyBkb2Vzbid0IHNlbmQgYSBjb250ZW50LWxlbmd0aCB0byB0aGUgc2VydmVyXG4gICAgICBkdXBsZXg6IFwiaGFsZlwiXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgIGludGVybmFsQWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbiAgaWYgKChfYTIgPSBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmFib3J0ZWQpIHtcbiAgICBoYW5kbGVBYm9ydCgpO1xuICB9IGVsc2Uge1xuICAgIChfYjIgPSBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBoYW5kbGVBYm9ydCk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZVByb21pc2U7XG4gIChfYyA9IG9wdGlvbnMuYWJvcnRTaWduYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgaGFuZGxlQWJvcnQpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG52YXIgbWF4Q29uY3VycmVudFVwbG9hZHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gNiA6IDg7XG52YXIgcGFydFNpemVJbkJ5dGVzID0gOCAqIDEwMjQgKiAxMDI0O1xudmFyIG1heEJ5dGVzSW5NZW1vcnkgPSBtYXhDb25jdXJyZW50VXBsb2FkcyAqIHBhcnRTaXplSW5CeXRlcyAqIDI7XG5mdW5jdGlvbiB1cGxvYWRBbGxQYXJ0cyh7XG4gIHVwbG9hZElkLFxuICBrZXksXG4gIHBhdGhuYW1lLFxuICBzdHJlYW0sXG4gIGhlYWRlcnMsXG4gIG9wdGlvbnNcbn0pIHtcbiAgZGVidWcoXCJtcHU6IHVwbG9hZCBpbml0XCIsIFwia2V5OlwiLCBrZXkpO1xuICBjb25zdCBpbnRlcm5hbEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBwYXJ0c1RvVXBsb2FkID0gW107XG4gICAgY29uc3QgY29tcGxldGVkUGFydHMgPSBbXTtcbiAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgbGV0IGFjdGl2ZVVwbG9hZHMgPSAwO1xuICAgIGxldCByZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IGN1cnJlbnRQYXJ0TnVtYmVyID0gMTtcbiAgICBsZXQgcmVqZWN0ZWQgPSBmYWxzZTtcbiAgICBsZXQgY3VycmVudEJ5dGVzSW5NZW1vcnkgPSAwO1xuICAgIGxldCBkb25lUmVhZGluZyA9IGZhbHNlO1xuICAgIGxldCBieXRlc1NlbnQgPSAwO1xuICAgIGxldCBhcnJheUJ1ZmZlcnMgPSBbXTtcbiAgICBsZXQgY3VycmVudFBhcnRCeXRlc1JlYWQgPSAwO1xuICAgIHJlYWQoKS5jYXRjaChjYW5jZWwpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJtcHU6IHVwbG9hZCByZWFkIHN0YXJ0XCIsXG4gICAgICAgIFwiYWN0aXZlVXBsb2FkczpcIixcbiAgICAgICAgYWN0aXZlVXBsb2FkcyxcbiAgICAgICAgXCJjdXJyZW50Qnl0ZXNJbk1lbW9yeTpcIixcbiAgICAgICAgYCR7Ynl0ZXMoY3VycmVudEJ5dGVzSW5NZW1vcnkpfS8ke2J5dGVzKG1heEJ5dGVzSW5NZW1vcnkpfWAsXG4gICAgICAgIFwiYnl0ZXNTZW50OlwiLFxuICAgICAgICBieXRlcyhieXRlc1NlbnQpXG4gICAgICApO1xuICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICB3aGlsZSAoY3VycmVudEJ5dGVzSW5NZW1vcnkgPCBtYXhCeXRlc0luTWVtb3J5ICYmICFyZWplY3RlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGRvbmVSZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlYnVnKFwibXB1OiB1cGxvYWQgcmVhZCBjb25zdW1lZCB0aGUgd2hvbGUgc3RyZWFtXCIpO1xuICAgICAgICAgICAgaWYgKGFycmF5QnVmZmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHBhcnRzVG9VcGxvYWQucHVzaCh7XG4gICAgICAgICAgICAgICAgcGFydE51bWJlcjogY3VycmVudFBhcnROdW1iZXIrKyxcbiAgICAgICAgICAgICAgICBibG9iOiBuZXcgQmxvYihhcnJheUJ1ZmZlcnMsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc2VuZFBhcnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRCeXRlc0luTWVtb3J5ICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgbGV0IHZhbHVlT2Zmc2V0ID0gMDtcbiAgICAgICAgICB3aGlsZSAodmFsdWVPZmZzZXQgPCB2YWx1ZS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdQYXJ0U2l6ZSA9IHBhcnRTaXplSW5CeXRlcyAtIGN1cnJlbnRQYXJ0Qnl0ZXNSZWFkO1xuICAgICAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgIHZhbHVlT2Zmc2V0ICsgcmVtYWluaW5nUGFydFNpemUsXG4gICAgICAgICAgICAgIHZhbHVlLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHZhbHVlLnNsaWNlKHZhbHVlT2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICAgICAgYXJyYXlCdWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgY3VycmVudFBhcnRCeXRlc1JlYWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHZhbHVlT2Zmc2V0ID0gZW5kT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJ0Qnl0ZXNSZWFkID09PSBwYXJ0U2l6ZUluQnl0ZXMpIHtcbiAgICAgICAgICAgICAgcGFydHNUb1VwbG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBjdXJyZW50UGFydE51bWJlcisrLFxuICAgICAgICAgICAgICAgIGJsb2I6IG5ldyBCbG9iKGFycmF5QnVmZmVycywge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhcnJheUJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgICAgY3VycmVudFBhcnRCeXRlc1JlYWQgPSAwO1xuICAgICAgICAgICAgICBzZW5kUGFydHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FuY2VsKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVidWcoXG4gICAgICAgIFwibXB1OiB1cGxvYWQgcmVhZCBlbmRcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzOlwiLFxuICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICBcImN1cnJlbnRCeXRlc0luTWVtb3J5OlwiLFxuICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgIGJ5dGVzKGJ5dGVzU2VudClcbiAgICAgICk7XG4gICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNlbmRQYXJ0KHBhcnQpIHtcbiAgICAgIGFjdGl2ZVVwbG9hZHMrKztcbiAgICAgIGRlYnVnKFxuICAgICAgICBcIm1wdTogdXBsb2FkIHNlbmQgcGFydCBzdGFydFwiLFxuICAgICAgICBcInBhcnROdW1iZXI6XCIsXG4gICAgICAgIHBhcnQucGFydE51bWJlcixcbiAgICAgICAgXCJzaXplOlwiLFxuICAgICAgICBwYXJ0LmJsb2Iuc2l6ZSxcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzOlwiLFxuICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICBcImN1cnJlbnRCeXRlc0luTWVtb3J5OlwiLFxuICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgIGJ5dGVzKGJ5dGVzU2VudClcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb21wbGV0ZWRQYXJ0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICAgICAgdXBsb2FkSWQsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBpbnRlcm5hbEFib3J0Q29udHJvbGxlcixcbiAgICAgICAgICBwYXJ0XG4gICAgICAgIH0pO1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBcIm1wdTogdXBsb2FkIHNlbmQgcGFydCBlbmRcIixcbiAgICAgICAgICBcInBhcnROdW1iZXI6XCIsXG4gICAgICAgICAgcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICAgIFwiYWN0aXZlVXBsb2Fkc1wiLFxuICAgICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgICAgXCJjdXJyZW50Qnl0ZXNJbk1lbW9yeTpcIixcbiAgICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgICBieXRlcyhieXRlc1NlbnQpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb21wbGV0ZWRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICBwYXJ0TnVtYmVyOiBwYXJ0LnBhcnROdW1iZXIsXG4gICAgICAgICAgZXRhZzogY29tcGxldGVkUGFydC5ldGFnXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50Qnl0ZXNJbk1lbW9yeSAtPSBwYXJ0LmJsb2Iuc2l6ZTtcbiAgICAgICAgYWN0aXZlVXBsb2Fkcy0tO1xuICAgICAgICBieXRlc1NlbnQgKz0gcGFydC5ibG9iLnNpemU7XG4gICAgICAgIGlmIChwYXJ0c1RvVXBsb2FkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZW5kUGFydHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9uZVJlYWRpbmcpIHtcbiAgICAgICAgICBpZiAoYWN0aXZlVXBsb2FkcyA9PT0gMCkge1xuICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICByZXNvbHZlKGNvbXBsZXRlZFBhcnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVhZGluZykge1xuICAgICAgICAgIHJlYWQoKS5jYXRjaChjYW5jZWwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYW5jZWwoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZW5kUGFydHMoKSB7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVidWcoXG4gICAgICAgIFwic2VuZCBwYXJ0c1wiLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHNcIixcbiAgICAgICAgYWN0aXZlVXBsb2FkcyxcbiAgICAgICAgXCJwYXJ0c1RvVXBsb2FkXCIsXG4gICAgICAgIHBhcnRzVG9VcGxvYWQubGVuZ3RoXG4gICAgICApO1xuICAgICAgd2hpbGUgKGFjdGl2ZVVwbG9hZHMgPCBtYXhDb25jdXJyZW50VXBsb2FkcyAmJiBwYXJ0c1RvVXBsb2FkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcGFydFRvU2VuZCA9IHBhcnRzVG9VcGxvYWQuc2hpZnQoKTtcbiAgICAgICAgaWYgKHBhcnRUb1NlbmQpIHtcbiAgICAgICAgICB2b2lkIHNlbmRQYXJ0KHBhcnRUb1NlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbChlcnJvcikge1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlamVjdGVkID0gdHJ1ZTtcbiAgICAgIGludGVybmFsQWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyb3IubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSkge1xuICAgICAgICByZWplY3QobmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcHV0LnRzXG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0IGFzIGlzUGxhaW5PYmplY3QyIH0gZnJvbSBcImlzLXBsYWluLW9iamVjdFwiO1xuXG4vLyBzcmMvbXVsdGlwYXJ0L2hlbHBlcnMudHNcbmltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSBcInN0cmVhbVwiO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gXCJpcy1idWZmZXJcIjtcbmZ1bmN0aW9uIHRvUmVhZGFibGVTdHJlYW0odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiB2YWx1ZS5zdHJlYW0oKTtcbiAgfVxuICBpZiAoaXNOb2RlSnNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gUmVhZGFibGUudG9XZWIodmFsdWUpO1xuICB9XG4gIGxldCBzdHJlYW1WYWx1ZTtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBzdHJlYW1WYWx1ZSA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKGlzTm9kZUpzQnVmZmVyT3JTdHJpbmcodmFsdWUpKSB7XG4gICAgc3RyZWFtVmFsdWUgPSB2YWx1ZS5idWZmZXI7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtVmFsdWUgPSBzdHJpbmdUb1VpbnQ4QXJyYXkodmFsdWUpO1xuICB9XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShzdHJlYW1WYWx1ZSk7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzTm9kZUpzUmVhZGFibGVTdHJlYW0odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUucGlwZSA9PT0gXCJmdW5jdGlvblwiICYmIHZhbHVlLnJlYWRhYmxlICYmIHR5cGVvZiB2YWx1ZS5fcmVhZCA9PT0gXCJmdW5jdGlvblwiICYmIC8vIEB0cy1leHBlY3QtZXJyb3IgX3JlYWRhYmxlU3RhdGUgZG9lcyBleGlzdHMgb24gUmVhZGFibGVcbiAgdHlwZW9mIHZhbHVlLl9yZWFkYWJsZVN0YXRlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9VaW50OEFycmF5KHMpIHtcbiAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHJldHVybiBlbmMuZW5jb2RlKHMpO1xufVxuZnVuY3Rpb24gaXNOb2RlSnNCdWZmZXJPclN0cmluZyhpbnB1dCkge1xuICByZXR1cm4gaXNCdWZmZXIoaW5wdXQpO1xufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L3VuY29udHJvbGxlZC50c1xuYXN5bmMgZnVuY3Rpb24gdW5jb250cm9sbGVkTXVsdGlwYXJ0VXBsb2FkKHBhdGhuYW1lLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKSB7XG4gIGRlYnVnKFwibXB1OiBpbml0XCIsIFwicGF0aG5hbWU6XCIsIHBhdGhuYW1lLCBcImhlYWRlcnM6XCIsIGhlYWRlcnMpO1xuICBjb25zdCBzdHJlYW0gPSB0b1JlYWRhYmxlU3RyZWFtKGJvZHkpO1xuICBjb25zdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZSA9IGF3YWl0IGNyZWF0ZU11bHRpcGFydFVwbG9hZChcbiAgICBwYXRobmFtZSxcbiAgICBoZWFkZXJzLFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgY29uc3QgcGFydHMgPSBhd2FpdCB1cGxvYWRBbGxQYXJ0cyh7XG4gICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgIHBhdGhuYW1lLFxuICAgIHN0cmVhbSxcbiAgICBoZWFkZXJzLFxuICAgIG9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgIHBhdGhuYW1lLFxuICAgIHBhcnRzLFxuICAgIGhlYWRlcnMsXG4gICAgb3B0aW9uc1xuICB9KTtcbiAgcmV0dXJuIGJsb2I7XG59XG5cbi8vIHNyYy9wdXQudHNcbmZ1bmN0aW9uIGNyZWF0ZVB1dE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zLFxuICBnZXRUb2tlbixcbiAgZXh0cmFDaGVja3Ncbn0pIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHB1dChwYXRobmFtZSwgYm9keU9yT3B0aW9ucywgb3B0aW9uc0lucHV0KSB7XG4gICAgY29uc3QgaXNGb2xkZXJDcmVhdGlvbiA9IHBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgICBpZiAoIWJvZHlPck9wdGlvbnMgJiYgIWlzRm9sZGVyQ3JlYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJib2R5IGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAoYm9keU9yT3B0aW9ucyAmJiBvcHRpb25zSW5wdXQgJiYgaXNGb2xkZXJDcmVhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcImJvZHkgaXMgbm90IGFsbG93ZWQgZm9yIGNyZWF0aW5nIGVtcHR5IGZvbGRlcnNcIik7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBpc0ZvbGRlckNyZWF0aW9uID8gdm9pZCAwIDogYm9keU9yT3B0aW9ucztcbiAgICBpZiAoYm9keSAhPT0gdm9pZCAwICYmIGlzUGxhaW5PYmplY3QyKGJvZHkpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBcIkJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbS4gWW91IHNlbnQgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCwgZG91YmxlIGNoZWNrIHdoYXQgeW91J3JlIHRyeWluZyB0byB1cGxvYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgLy8gd2hlbiBubyBib2R5IGlzIHJlcXVpcmVkIChmb3IgZm9sZGVyIGNyZWF0aW9ucykgb3B0aW9ucyBhcmUgdGhlIHNlY29uZCBhcmd1bWVudFxuICAgICAgb3B0aW9uczogaXNGb2xkZXJDcmVhdGlvbiA/IGJvZHlPck9wdGlvbnMgOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLm11bHRpcGFydCA9PT0gdHJ1ZSAmJiBib2R5KSB7XG4gICAgICByZXR1cm4gdW5jb250cm9sbGVkTXVsdGlwYXJ0VXBsb2FkKHBhdGhuYW1lLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgICAgYC8ke3BhdGhuYW1lfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgLy8gcmVxdWlyZWQgaW4gb3JkZXIgdG8gc3RyZWFtIHNvbWUgYm9keSB0eXBlcyB0byBDbG91ZGZsYXJlXG4gICAgICAgIC8vIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBpbiBOb2RlLmpzLCB3ZSBtYXkgaGF2ZSB0byBmZWF0dXJlIGRldGVjdCB0aGlzXG4gICAgICAgIC8vIG5vdGU6IHRoaXMgZG9lc24ndCBzZW5kIGEgY29udGVudC1sZW5ndGggdG8gdGhlIHNlcnZlclxuICAgICAgICBkdXBsZXg6IFwiaGFsZlwiLFxuICAgICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICBkb3dubG9hZFVybDogcmVzcG9uc2UuZG93bmxvYWRVcmwsXG4gICAgICBwYXRobmFtZTogcmVzcG9uc2UucGF0aG5hbWUsXG4gICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUsXG4gICAgICBjb250ZW50RGlzcG9zaXRpb246IHJlc3BvbnNlLmNvbnRlbnREaXNwb3NpdGlvblxuICAgIH07XG4gIH07XG59XG5cbi8vIHNyYy9tdWx0aXBhcnQvY3JlYXRlLXVwbG9hZGVyLnRzXG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0IGFzIGlzUGxhaW5PYmplY3QzIH0gZnJvbSBcImlzLXBsYWluLW9iamVjdFwiO1xuZnVuY3Rpb24gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgICAgYXN5bmMgdXBsb2FkUGFydChwYXJ0TnVtYmVyLCBib2R5KSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0Myhib2R5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgICAgICBcIkJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbS4gWW91IHNlbnQgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCwgZG91YmxlIGNoZWNrIHdoYXQgeW91J3JlIHRyeWluZyB0byB1cGxvYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwbG9hZFBhcnQoe1xuICAgICAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICAgICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBwYXJ0OiB7IHBhcnROdW1iZXIsIGJsb2I6IGJvZHkgfSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXRhZzogcmVzdWx0LmV0YWcsXG4gICAgICAgICAgcGFydE51bWJlclxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGNvbXBsZXRlKHBhcnRzKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gICAgICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgICAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQge1xuICBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYsXG4gIEJsb2JFcnJvcixcbiAgZ2V0RG93bmxvYWRVcmwsXG4gIEJsb2JBY2Nlc3NFcnJvcixcbiAgQmxvYlN0b3JlTm90Rm91bmRFcnJvcixcbiAgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IsXG4gIEJsb2JVbmtub3duRXJyb3IsXG4gIEJsb2JOb3RGb3VuZEVycm9yLFxuICBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSxcbiAgQmxvYlNlcnZpY2VSYXRlTGltaXRlZCxcbiAgQmxvYlJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gIHJlcXVlc3RBcGksXG4gIGNyZWF0ZUNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kLFxuICBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QsXG4gIGNyZWF0ZVB1dE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1RUlJISjU3NC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@vercel/blob/dist/chunk-QRRHJ574.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@vercel/blob/dist/index.js":
/*!*****************************************************!*\
  !*** ../../node_modules/@vercel/blob/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* reexport safe */ _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.BlobAccessError),\n/* harmony export */   BlobError: () => (/* reexport safe */ _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.BlobError),\n/* harmony export */   BlobNotFoundError: () => (/* reexport safe */ _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.BlobNotFoundError),\n/* harmony export */   BlobRequestAbortedError: () => (/* reexport safe */ _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.BlobRequestAbortedError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* reexport safe */ _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.BlobServiceNotAvailable),\n/* harmony export */   BlobServiceRateLimited: () => (/* reexport safe */ _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.BlobServiceRateLimited),\n/* harmony export */   BlobStoreNotFoundError: () => (/* reexport safe */ _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* reexport safe */ _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* reexport safe */ _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.BlobUnknownError),\n/* harmony export */   completeMultipartUpload: () => (/* binding */ completeMultipartUpload),\n/* harmony export */   copy: () => (/* binding */ copy),\n/* harmony export */   createMultipartUpload: () => (/* binding */ createMultipartUpload),\n/* harmony export */   createMultipartUploader: () => (/* binding */ createMultipartUploader),\n/* harmony export */   del: () => (/* binding */ del),\n/* harmony export */   getDownloadUrl: () => (/* reexport safe */ _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.getDownloadUrl),\n/* harmony export */   head: () => (/* binding */ head),\n/* harmony export */   list: () => (/* binding */ list),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   uploadPart: () => (/* binding */ uploadPart)\n/* harmony export */ });\n/* harmony import */ var _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-QRRHJ574.js */ \"(rsc)/../../node_modules/@vercel/blob/dist/chunk-QRRHJ574.js\");\n\n\n// src/del.ts\nasync function del(url, options) {\n  await (0,_chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    \"/delete\",\n    {\n      method: \"POST\",\n      headers: { \"content-type\": \"application/json\" },\n      body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] }),\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n}\n\n// src/head.ts\nasync function head(url, options) {\n  const searchParams = new URLSearchParams({ url });\n  const response = await (0,_chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `?${searchParams.toString()}`,\n    // HEAD can't have body as a response, so we use GET\n    {\n      method: \"GET\",\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    size: response.size,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition,\n    cacheControl: response.cacheControl,\n    uploadedAt: new Date(response.uploadedAt)\n  };\n}\n\n// src/list.ts\nasync function list(options) {\n  var _a;\n  const searchParams = new URLSearchParams();\n  if (options == null ? void 0 : options.limit) {\n    searchParams.set(\"limit\", options.limit.toString());\n  }\n  if (options == null ? void 0 : options.prefix) {\n    searchParams.set(\"prefix\", options.prefix);\n  }\n  if (options == null ? void 0 : options.cursor) {\n    searchParams.set(\"cursor\", options.cursor);\n  }\n  if (options == null ? void 0 : options.mode) {\n    searchParams.set(\"mode\", options.mode);\n  }\n  const response = await (0,_chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `?${searchParams.toString()}`,\n    {\n      method: \"GET\",\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n  if ((options == null ? void 0 : options.mode) === \"folded\") {\n    return {\n      folders: (_a = response.folders) != null ? _a : [],\n      cursor: response.cursor,\n      hasMore: response.hasMore,\n      blobs: response.blobs.map(mapBlobResult)\n    };\n  }\n  return {\n    cursor: response.cursor,\n    hasMore: response.hasMore,\n    blobs: response.blobs.map(mapBlobResult)\n  };\n}\nfunction mapBlobResult(blobResult) {\n  return {\n    url: blobResult.url,\n    downloadUrl: blobResult.downloadUrl,\n    pathname: blobResult.pathname,\n    size: blobResult.size,\n    uploadedAt: new Date(blobResult.uploadedAt)\n  };\n}\n\n// src/copy.ts\nasync function copy(fromUrl, toPathname, options) {\n  if (!options) {\n    throw new _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new _chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.BlobError('access must be \"public\"');\n  }\n  const headers = {};\n  if (options.addRandomSuffix !== void 0) {\n    headers[\"x-add-random-suffix\"] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (options.contentType) {\n    headers[\"x-content-type\"] = options.contentType;\n  }\n  if (options.cacheControlMaxAge !== void 0) {\n    headers[\"x-cache-control-max-age\"] = options.cacheControlMaxAge.toString();\n  }\n  const response = await (0,_chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `/${toPathname}?fromUrl=${fromUrl}`,\n    {\n      method: \"PUT\",\n      headers,\n      signal: options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition\n  };\n}\n\n// src/index.ts\nvar put = (0,_chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.createPutMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar createMultipartUpload = (0,_chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.createCreateMultipartUploadMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar createMultipartUploader = (0,_chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.createCreateMultipartUploaderMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar uploadPart = (0,_chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.createUploadPartMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar completeMultipartUpload = (0,_chunk_QRRHJ574_js__WEBPACK_IMPORTED_MODULE_0__.createCompleteMultipartUploadMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0B2ZXJjZWwvYmxvYi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUI2Qjs7QUFFN0I7QUFDQTtBQUNBLFFBQVEsOERBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRCw2QkFBNkIsd0NBQXdDO0FBQ3JFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQseUJBQXlCLDhEQUFVO0FBQ25DLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhEQUFVO0FBQ25DLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlEQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLHlEQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOERBQVU7QUFDbkMsUUFBUSxXQUFXLFdBQVcsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsbUVBQWU7QUFDekI7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCLHFGQUFpQztBQUM3RDtBQUNBLENBQUM7QUFDRCw4QkFBOEIsdUZBQW1DO0FBQ2pFO0FBQ0EsQ0FBQztBQUNELGlCQUFpQiwwRUFBc0I7QUFDdkM7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLHVGQUFtQztBQUNqRTtBQUNBLENBQUM7QUFxQkM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvaW5kZXguanM/NmI3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCbG9iQWNjZXNzRXJyb3IsXG4gIEJsb2JFcnJvcixcbiAgQmxvYk5vdEZvdW5kRXJyb3IsXG4gIEJsb2JSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSxcbiAgQmxvYlNlcnZpY2VSYXRlTGltaXRlZCxcbiAgQmxvYlN0b3JlTm90Rm91bmRFcnJvcixcbiAgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IsXG4gIEJsb2JVbmtub3duRXJyb3IsXG4gIGNyZWF0ZUNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kLFxuICBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZGVyTWV0aG9kLFxuICBjcmVhdGVQdXRNZXRob2QsXG4gIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QsXG4gIGdldERvd25sb2FkVXJsLFxuICByZXF1ZXN0QXBpXG59IGZyb20gXCIuL2NodW5rLVFSUkhKNTc0LmpzXCI7XG5cbi8vIHNyYy9kZWwudHNcbmFzeW5jIGZ1bmN0aW9uIGRlbCh1cmwsIG9wdGlvbnMpIHtcbiAgYXdhaXQgcmVxdWVzdEFwaShcbiAgICBcIi9kZWxldGVcIixcbiAgICB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogeyBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1cmxzOiBBcnJheS5pc0FycmF5KHVybCkgPyB1cmwgOiBbdXJsXSB9KSxcbiAgICAgIHNpZ25hbDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApO1xufVxuXG4vLyBzcmMvaGVhZC50c1xuYXN5bmMgZnVuY3Rpb24gaGVhZCh1cmwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHVybCB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgIGA/JHtzZWFyY2hQYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgIC8vIEhFQUQgY2FuJ3QgaGF2ZSBib2R5IGFzIGEgcmVzcG9uc2UsIHNvIHdlIHVzZSBHRVRcbiAgICB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBzaWduYWw6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICBkb3dubG9hZFVybDogcmVzcG9uc2UuZG93bmxvYWRVcmwsXG4gICAgcGF0aG5hbWU6IHJlc3BvbnNlLnBhdGhuYW1lLFxuICAgIHNpemU6IHJlc3BvbnNlLnNpemUsXG4gICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlLFxuICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcmVzcG9uc2UuY29udGVudERpc3Bvc2l0aW9uLFxuICAgIGNhY2hlQ29udHJvbDogcmVzcG9uc2UuY2FjaGVDb250cm9sLFxuICAgIHVwbG9hZGVkQXQ6IG5ldyBEYXRlKHJlc3BvbnNlLnVwbG9hZGVkQXQpXG4gIH07XG59XG5cbi8vIHNyYy9saXN0LnRzXG5hc3luYyBmdW5jdGlvbiBsaXN0KG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmxpbWl0KSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcImxpbWl0XCIsIG9wdGlvbnMubGltaXQudG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlZml4KSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcInByZWZpeFwiLCBvcHRpb25zLnByZWZpeCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY3Vyc29yKSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcImN1cnNvclwiLCBvcHRpb25zLmN1cnNvcik7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZSkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJtb2RlXCIsIG9wdGlvbnMubW9kZSk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgIGA/JHtzZWFyY2hQYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIHNpZ25hbDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApO1xuICBpZiAoKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZSkgPT09IFwiZm9sZGVkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9sZGVyczogKF9hID0gcmVzcG9uc2UuZm9sZGVycykgIT0gbnVsbCA/IF9hIDogW10sXG4gICAgICBjdXJzb3I6IHJlc3BvbnNlLmN1cnNvcixcbiAgICAgIGhhc01vcmU6IHJlc3BvbnNlLmhhc01vcmUsXG4gICAgICBibG9iczogcmVzcG9uc2UuYmxvYnMubWFwKG1hcEJsb2JSZXN1bHQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGN1cnNvcjogcmVzcG9uc2UuY3Vyc29yLFxuICAgIGhhc01vcmU6IHJlc3BvbnNlLmhhc01vcmUsXG4gICAgYmxvYnM6IHJlc3BvbnNlLmJsb2JzLm1hcChtYXBCbG9iUmVzdWx0KVxuICB9O1xufVxuZnVuY3Rpb24gbWFwQmxvYlJlc3VsdChibG9iUmVzdWx0KSB7XG4gIHJldHVybiB7XG4gICAgdXJsOiBibG9iUmVzdWx0LnVybCxcbiAgICBkb3dubG9hZFVybDogYmxvYlJlc3VsdC5kb3dubG9hZFVybCxcbiAgICBwYXRobmFtZTogYmxvYlJlc3VsdC5wYXRobmFtZSxcbiAgICBzaXplOiBibG9iUmVzdWx0LnNpemUsXG4gICAgdXBsb2FkZWRBdDogbmV3IERhdGUoYmxvYlJlc3VsdC51cGxvYWRlZEF0KVxuICB9O1xufVxuXG4vLyBzcmMvY29weS50c1xuYXN5bmMgZnVuY3Rpb24gY29weShmcm9tVXJsLCB0b1BhdGhuYW1lLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJtaXNzaW5nIG9wdGlvbnMsIHNlZSB1c2FnZVwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5hY2Nlc3MgIT09IFwicHVibGljXCIpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKCdhY2Nlc3MgbXVzdCBiZSBcInB1YmxpY1wiJyk7XG4gIH1cbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAob3B0aW9ucy5hZGRSYW5kb21TdWZmaXggIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbXCJ4LWFkZC1yYW5kb20tc3VmZml4XCJdID0gb3B0aW9ucy5hZGRSYW5kb21TdWZmaXggPyBcIjFcIiA6IFwiMFwiO1xuICB9XG4gIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlKSB7XG4gICAgaGVhZGVyc1tcIngtY29udGVudC10eXBlXCJdID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgfVxuICBpZiAob3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UgIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbXCJ4LWNhY2hlLWNvbnRyb2wtbWF4LWFnZVwiXSA9IG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlLnRvU3RyaW5nKCk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgIGAvJHt0b1BhdGhuYW1lfT9mcm9tVXJsPSR7ZnJvbVVybH1gLFxuICAgIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICBkb3dubG9hZFVybDogcmVzcG9uc2UuZG93bmxvYWRVcmwsXG4gICAgcGF0aG5hbWU6IHJlc3BvbnNlLnBhdGhuYW1lLFxuICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSxcbiAgICBjb250ZW50RGlzcG9zaXRpb246IHJlc3BvbnNlLmNvbnRlbnREaXNwb3NpdGlvblxuICB9O1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBwdXQgPSBjcmVhdGVQdXRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY2FjaGVDb250cm9sTWF4QWdlXCIsIFwiYWRkUmFuZG9tU3VmZml4XCIsIFwiY29udGVudFR5cGVcIl1cbn0pO1xudmFyIGNyZWF0ZU11bHRpcGFydFVwbG9hZCA9IGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjYWNoZUNvbnRyb2xNYXhBZ2VcIiwgXCJhZGRSYW5kb21TdWZmaXhcIiwgXCJjb250ZW50VHlwZVwiXVxufSk7XG52YXIgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXIgPSBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjYWNoZUNvbnRyb2xNYXhBZ2VcIiwgXCJhZGRSYW5kb21TdWZmaXhcIiwgXCJjb250ZW50VHlwZVwiXVxufSk7XG52YXIgdXBsb2FkUGFydCA9IGNyZWF0ZVVwbG9hZFBhcnRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY2FjaGVDb250cm9sTWF4QWdlXCIsIFwiYWRkUmFuZG9tU3VmZml4XCIsIFwiY29udGVudFR5cGVcIl1cbn0pO1xudmFyIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkID0gY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY2FjaGVDb250cm9sTWF4QWdlXCIsIFwiYWRkUmFuZG9tU3VmZml4XCIsIFwiY29udGVudFR5cGVcIl1cbn0pO1xuZXhwb3J0IHtcbiAgQmxvYkFjY2Vzc0Vycm9yLFxuICBCbG9iRXJyb3IsXG4gIEJsb2JOb3RGb3VuZEVycm9yLFxuICBCbG9iUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUsXG4gIEJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQsXG4gIEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IsXG4gIEJsb2JTdG9yZVN1c3BlbmRlZEVycm9yLFxuICBCbG9iVW5rbm93bkVycm9yLFxuICBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCxcbiAgY29weSxcbiAgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkLFxuICBjcmVhdGVNdWx0aXBhcnRVcGxvYWRlcixcbiAgZGVsLFxuICBnZXREb3dubG9hZFVybCxcbiAgaGVhZCxcbiAgbGlzdCxcbiAgcHV0LFxuICB1cGxvYWRQYXJ0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@vercel/blob/dist/index.js\n");

/***/ })

};
;